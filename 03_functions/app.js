const square = function (number){
    return number * number
}
console.log(square(2));


function noise(){
    console.log('hasbdhadad');
}
noise()


function power(base, expo){
    let res = 1
    for (let counter = 0; counter < expo; counter++){
        res *= base
    }
    return res
}
console.log(power(2, 3));

/*
    Привязки, объявленные с помощью ключевых слов let и const, на самом

    деле являются локальными для блока, внутри которого они объявлены. По-
    этому если вы создадите одну из таких привязок внутри цикла, то код до

    и после данного цикла не сможет его •увидеть•. До 2015 года вjavaScript

    только функции могли создавать новые области видимости, поэтому при-
    вязки, созданные в старом стиле с помощью ключевого слова var, видны во

    всей функции, в которой они появились, либо во всей глобальной области
    видимости, если они не входят в функцию.
*/
let x = 10                    
if (true) {                   
    var y = 20;               
    var z = 30;               
    console.log(x + y + z);   
}                             
console.log(x + y);           



/* 
    Каждая область видимости может •выглядывать• в область, которая ее
    окружает, поэтому в данном примере привязка х видна внутри блока.

    Исключение составляют случаи, когда несколько привязок имеют одно и то
    же имя - тогда код может видеть только самую внутреннюю из привязок.
    Например, когда код внутри функции halve ссылается на n, то он видит
    собственную привязку n, а не глобальную n.
*/
function halve(n) {           
    return n / 2              
}                             
let n = 10                    
console.log(halve(100));      
console.log(n);               


const humus = function(factor){
    const ingredient = function(amount, unit, name){
        let ingredientAmount = amount * factor
        if(ingredientAmount > 1){
            unit += 's'
        }
        console.log(`${ingredientAmount} ${unit} ${name}`);
    }
    ingredient(1, "банка", "нута");
    ingredient(0.25, "стакан", "кунжутной пасты");
    ingredient(0.25, "стакан", "лимонного сока");
    ingredient(1, "зубок", "чеснока");
    ingredient(2, "столовые ложки", "оливкового масла");
    ingredient(0.5, "чайной ложки", "кумина");
}
humus(21)

console.log('Стрелочные функции');
/*
    Существует третий способ записи для функций, и он очень отличается от
    остальных. Вместо ключевого слова function используется стрелка ( => ),
    состоящая из знака равенства и символа "больше" (не путать с оператором
    "больше или равно", который пишется как >= ).
*/

const square2 = (number) => { 
        return number * number
}
console.log(square2(3));


/* 
    Стрелка ставится после списка параметров, затем идет тело функции. Стрелка
    выражает что-то вроде «эти входные данные (параметры) дают этот резуль-
    тат (тело функции).

    Если имя параметра только одно, можно опустить круглые скобки, в кото-
    рые заключен список параметров. Если тело функции представляет собой
    единственное выражение, а не блок в фигурных скобках, то функция будет
    возвращать это выражение. Таким образом, следующие два определения
    square делают одно и то же:

    const squarel = (х) => { return х * х; };
    const square2 = х => х * х;
    
    Если у стрелочной функции вообще нет параметров, то ее список параметров
    
    представляет собой просто пустые скобки.
    const horn = () => {
        console.log("Toot");
    };

*/

function minus(num1, num2) {
    if(num2 === undefined){
        return -num1
    }
    else{
        return num1 - num2
    }
}
console.log(minus(1));
console.log(minus(1, 1));